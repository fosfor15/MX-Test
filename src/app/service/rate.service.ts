import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

import { Observable, switchMap, timer, map, catchError } from 'rxjs';

import * as X2JS from 'x2js';
const x2js = new X2JS();

import { Currency } from '../interfaces/currency';


@Injectable({
    providedIn: 'root'
})
export class RateService {

    /* Список эндпоинтов для получения курса Евро к Рублю */
    private endpoints: Array<string> = [
        'https://www.cbr-xml-daily.ru/daily_utf8.xm',
        'https://www.cbr-xml-daily.ru/daily_json.js'
    ];
    /* ToDo:
    Предполагается что этот список может быть расширен.
    В первом случае список может быть расширен через изменение текущего свойства здесь в сервисе.
    В ином случае, если этот список должен редактироваться пользователем (администратором, а не простым клиентом), в таком случае данный функционал может быть реализован в виде отдельного компонента с элементами-контролами (формой), из которого эндпоинты могут подаваться как аргументы в методы данного сервиса. */


    /* Инициализация сервиса */
    constructor(
        private httpClient: HttpClient
    ) { }


    /* Метод для получения курса Евро к Рублю по одному эндпоинту с возможностью переключения на следующий эндпоинт */
    private getRateByEndpoint$(endpointID: number): Observable<string> {
        console.log('endpointID :>> ', endpointID);

        return this.httpClient.get(this.endpoints[endpointID], { responseType: 'text' })
            .pipe(
                /* Перезапуск запроса на эндпоинт, следующий после ошибочного или недоступного */
                catchError(() =>
                    this.getRateByEndpoint$(++endpointID)
                )
            );

        /* На мой взгляд это наиболее оптимальное решение для переключения запросов с ошибочных или недоступных эндпоинтов.
        При появлении ошибки или отсутствия доступа к первому эндпоинту выполняется запрос на следующий эндпоинт. При этом может появится ощутимая задержка в получении данных по следующему эндпоинту, которая обусловлена временем ожидания ошибки по первому и временем запроса по второму эндпоинту. Эта задержка может иметь различную длительность, но в порядке 10 секунд изменение курса валюты не очень значительное, так что задержка порядка 1-2 секунд будет также малозначительной. За время задержки пользователю будет выводится предыдущее значение курса, которое не сильно изменится за время дополнительного ожидания.
        При следующих запросах в первую очередь будет использовать самый приоритетный эндпоинт, по которому либо будет возвращаться ошибки и цикл с переключением будет повторяться, либо по которому в какой-то момент в будущем вернётся нормальный ответ. Тогда этот эндпоинт будет использовать вновь как более приоритетный, а запросы на следующие эндпоинты не будут отправляться.
        Возможно иное решение, при котором запросы будут отправляться на все эндпоинты сразу, однако данные будет использоваться только из одного самого приоритетного и доступного эндпоинта. При таком решении задержка между двумя эндпоинтами будет минимальной. Однако такое решение приведёт к расходованию ресурсов браузера и систем передачи данных.  */
    }


    /* Метод для обработки данных в ответах сервера */
    private processData(data: string): Map<string, Currency> {

        /* Создание структуры Map, где в качестве ключей используются буквенные коды валют charCode, а в качестве значений используется весь объект валюты */
        const currenciesMap: Map<string, Currency> = new Map<string, Currency>();

        /* Обработка XML-данных */
        if (data.startsWith('<?xml')) {
            const dataObj = x2js.xml2js(data) as { ValCurs: any };

            dataObj.ValCurs.Valute.forEach((currency: Currency) => {
                /* Преобразование значения курса к числовому типу */
                currency = {
                    ...currency,
                    Value: parseFloat( String(currency.Value).replace(',', '.') )
                };

                currenciesMap.set(currency.CharCode, currency);
            })
        }

        /* Обработка JSON-данных */
        else {
            const dataObj = JSON.parse(data);

            for (const charCode in dataObj.Valute) {
                currenciesMap.set(charCode, dataObj.Valute[charCode] as Currency);
            }
        }

        return currenciesMap;
    }


    /* Метод для инвертирования порядка опроса эндпоинтов */
    public reverseEndpoints(): void {
        this.endpoints.reverse();

        /* Это простое решение для установки порядка опроса эндпоинтов. Если же их будет более 2-х, в таком случае возможно хранение эндпоинтов в структуре типа Map по ключам, и также потребуется изменение этого метода, в котором порядок опроса можно установить через передачу массива с ключами эндпоинтов, в котором будет указан необходимый порядок опроса. */
    }


    /* Метод для получения курса Евро к Рублю каждые 10 секунд с возможностью переключения при недоступности источника */
    public getRate$(): Observable<Map<string, Currency>> {
        return timer(0, 1e4)
            .pipe(
                switchMap(() =>
                    this.getRateByEndpoint$(0)
                ),
                map((data: string) => this.processData(data))
            );
    }

}
